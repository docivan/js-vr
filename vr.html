<!DOCTYPE html>
<html>
<head>
<title>VR testing</title>

<script>
var c, ctx;
var framerate = 30;
var debug = 0;

var cellw = 5;
var draw_dist = cellw * 100; //TODO should be map_side * cellw * 1.5
var ray_step = 0.2;
var collision_method = 1; //0 - ray step; 1 - exact

var px = cellw*3, py = cellw*4, pa = -Math.PI / 2; //pa = player angle
var fov = Math.PI / 2;
var bkg_grad;

var kb_left = 0, kb_right = 0, kb_up = 0, kb_down = 0, kb_a = 0, kb_z = 0;
var rot_step = Math.PI / 45;
var mv_step = 0.5;

var mm_scale = 5;

//TODO define map size!

var map = [
	//"0123456789"
	"##########", //0
	"##.......#", //1
	"#..#.....#", //2
	"#......###", //3
	"#........#", //4
	"#...##...#", //5
	"#........#", //6
	"#..####..#", //7
	"#.....#..#", //8
	"##########"  //9
];

function init() {
	c = document.getElementById("myCanvas");
	ctx = c.getContext("2d");
	
	bkg_grad=ctx.createLinearGradient(0,0,0,c.height);
	bkg_grad.addColorStop(0,"black");
	bkg_grad.addColorStop(0.5,"white");
	bkg_grad.addColorStop(1,"black");
	
	//TODO compile edges!
	
	window.setInterval(function(){
		update();
	}, 1000/framerate);
	
	document.addEventListener('keydown', function(event) {
		switch(event.keyCode) {
			case 37: kb_left = 1; break;
			case 38: kb_up = 1; break;
			case 39: kb_right = 1; break;
			case 40: kb_down = 1; break;
			case 65: kb_a = 1; break;
			case 90: kb_z = 1; break;
		}
	});
	
	document.addEventListener('keyup', function(event) {
		switch(event.keyCode) {
			case 37: kb_left = 0; break;
			case 38: kb_up = 0; break;
			case 39: kb_right = 0; break;
			case 40: kb_down = 0; break;
			case 65: kb_a = 0; break;
			case 90: kb_z = 0; break;
		}
	});
}

function detect_collision(x, y) {
	var arr_x = Math.floor(x / cellw);
	var arr_y = Math.floor(y / cellw);
	
	if(arr_x <0 || arr_y <0) //out of bounds
		return 1;
	
	coll_cell_x = parseInt(arr_x);
	coll_cell_y = parseInt(arr_y);
	
	if(map[coll_cell_y][coll_cell_x] == "#")
		return 1; // hit
	else
		return 0;
}

function handle_kb() {
	if(kb_a)
		fov += rot_step;
	if(kb_z)
		fov -= rot_step;
	
	if(kb_left)
		pa -= rot_step;
	if(kb_right)
		pa += rot_step;
	
	if(kb_up) {
		var npx = px + mv_step * Math.cos(pa);
		var npy = py + mv_step * Math.sin(pa);
		
		if(!detect_collision(npx, npy)) {
			px = npx;
			py = npy;
		}
	}
	
	if(kb_down) {
		var npx = px - mv_step * Math.cos(pa);
		var npy = py - mv_step * Math.sin(pa);
		
		if(!detect_collision(npx, npy)) {
			px = npx;
			py = npy;
		}
	}
}

function draw_minimap () {
	var mm_x = c.width - mm_scale*10;
	var mm_y = c.height - mm_scale*10;
	
	for(var y=0; y<10; y++)
		for(var x=0; x<10; x++) {
			if(map[y][x] == "#")
				ctx.fillStyle = "#000000";
			else
				ctx.fillStyle = "#ffffff";
			
			ctx.fillRect(mm_x + x*mm_scale, mm_y + y*mm_scale, mm_scale, mm_scale);
		}
	
	var mm_px = mm_x + px / (10*cellw) * (10*mm_scale);
	var mm_py = mm_y + py / (10*cellw) * (10*mm_scale);
	
	//draw angle..
	var mm_pax = mm_scale * Math.cos(pa);
	var mm_pay = mm_scale * Math.sin(pa);
	
	ctx.strokeStyle="#0000ff";
	ctx.beginPath();
	ctx.moveTo(mm_px, mm_py);
	ctx.lineTo(mm_px + mm_pax, mm_py + mm_pay);
	ctx.stroke();
	
	//draw player..
	ctx.fillStyle = "#ff0000";		
	ctx.fillRect(mm_px - mm_scale/4, mm_py - mm_scale/4, mm_scale/2, mm_scale/2);
}

function calc_dist(cell_x, cell_y, ray_a) {
	var exact_dist=Number.MAX_SAFE_INTEGER, ndist = 0.0;
	
	var k = Math.tan(ray_a);
	var b = py - k * px;
	
	/* a .
	   . b */
	var ptax = cell_x * cellw;
	var ptay = cell_y * cellw;
	var ptbx = (cell_x+1) * cellw;
	var ptby = (cell_y+1) * cellw;
	
	//visible ray in front of player: [px, py] => [px + vx*draw_dist, py + vy*draw_dist]
	var ux1 = px;
	var uy1 = py;
	var ux2 = px + Math.cos(ray_a)*draw_dist;
	var uy2 = py + Math.sin(ray_a)*draw_dist;
	var tmp;
	
	if(ux1>ux2) {tmp=ux1; ux1=ux2; ux2=tmp;}
	if(uy1>uy2) {tmp=uy1; uy1=uy2; uy2=tmp;}
	
	
	//bottom
	var fx2 = (ptby - b) / k;
	if(fx2>=ptax && fx2<=ptbx && fx2>=ux1 && fx2<=ux2 && ptby>=uy1 && ptby<=uy2) {
		ndist = Math.sqrt((px-fx2)*(px-fx2) + (py-ptby)*(py-ptby));
		if(ndist < exact_dist)
			exact_dist = ndist;
	}
	
	//left
	var fy1 = k*ptax + b;
	if(fy1>=ptay && fy1<=ptby  && ptax>=ux1 && ptax<=ux2 && fy1>=uy1 && fy1<=uy2) {
		ndist = Math.sqrt((px-ptax)*(px-ptax) + (py-fy1)*(py-fy1));
		if(ndist<exact_dist)
			exact_dist = ndist;
	}
	
	//top
	var fx1 = (ptay - b) / k;
	if(fx1>=ptax && fx1<=ptbx  && fx1>=ux1 && fx1<=ux2 && ptay>=uy1 && ptay<=uy2) {
		ndist = Math.sqrt((px-fx1)*(px-fx1) + (py-ptay)*(py-ptay));		
		if(ndist<exact_dist)
			exact_dist = ndist;
	}
	
	//right
	var fy2 = k*ptbx + b;
	if(fy2>=ptay && fy2<=ptby  && ptbx>=ux1 && ptbx<=ux2 && fy2>=uy1 && fy2<=uy2) {
		ndist = Math.sqrt((px-ptbx)*(px-ptbx) + (py-fy2)*(py-fy2));
		if(ndist<exact_dist)
			exact_dist = ndist;
	}
	
	return exact_dist;
}

function update() {
	handle_kb();
	
	ctx.fillStyle=bkg_grad;
	ctx.fillRect(0,0,c.width,c.height);
	
	for(var i = 0; i<c.width; i++) {
		var ray_a = (pa - fov / 2) + (i/c.width)*fov;
		
		var dist = 0;
		
		if(collision_method == 1) {
			var dist = Number.MAX_SAFE_INTEGER;
			
			for(var y=0; y<10; y++)
				for(var x=0; x<10; x++)
					if(map[y][x] == "#") {
						var ndist = calc_dist(x, y, ray_a);
						
						if(ndist < dist)
							dist = ndist;
					}
		}
		else {
			var vx = Math.cos(ray_a);
			var vy = Math.sin(ray_a);
		
			while (dist < draw_dist) {
				dist += ray_step;
			
				var testx = px + vx*dist;
				var testy = py + vy*dist;
			
				if( detect_collision(testx, testy) )
					break;
			}
		}
		
		var ceil_y = c.height / 2 - c.height / dist; //if dist = 1 => negative
		if(ceil_y < 0)
			ceil_y=0;
		
		var floor_y = c.height - ceil_y;
		var col = parseInt(255 - 255 * ceil_y/(c.height/2) ).toString(16);
		if(col.length < 2)
			col = "0" + col;
		
		ctx.fillStyle="#0000" + col;
		ctx.fillRect(i, ceil_y, 1, floor_y-ceil_y);
		
		//if(i == 0)
			//console.log("#0000" + col + " : " + ceil_y.toString() + " : " + (floor_y - ceil_y).toString());
	}
	
	draw_minimap();
}

</script> 

</head>

<body onload="init()">
<canvas id="myCanvas" width="400" height="400" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>
</body>
</html>

