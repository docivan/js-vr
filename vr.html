<!DOCTYPE html>
<html>
<head>
<title>VR testing</title>

<script>
var c, ctx;
var framerate = 30;
var debug = 1;

var auto_spin_mode = 0;
var shader_checkers = 6;
var cellw = 5;
var draw_dist = cellw * 100; //TODO should be map_side * cellw * 1.5
var ray_step = 0.2;
var collision_method = 1; //0 - ray step; 1 - exact

var px = cellw*3, py = cellw*4, pa = -Math.PI / 2; //pa = player angle
var fov = Math.PI / 2;
var bkg_grad;

var kb_left = 0, kb_right = 0, kb_up = 0, kb_down = 0, kb_a = 0, kb_z = 0;
var rot_step = Math.PI / 45;
var mv_step = 0.5;

var mm_scale = 5;

//TODO define map size!

var map = [
	//"0123456789"
	"##########", //0
	"##.......#", //1
	"#..#.....#", //2
	"#......###", //3
	"#........#", //4
	"#...##...#", //5
	"#........#", //6
	"#..####..#", //7
	"#.....#..#", //8
	"##########"  //9
];

function init() {
	c = document.getElementById("myCanvas");
	ctx = c.getContext("2d");
	
	if(debug)
		c.style="border:1px solid #d3d3d3;";
	
	bkg_grad=ctx.createLinearGradient(0,0,0,c.height);
	bkg_grad.addColorStop(0,"black");
	bkg_grad.addColorStop(0.5,"white");
	bkg_grad.addColorStop(1,"black");
	
	//TODO compile edges!
	
	window.setInterval(function(){
		update();
	}, 1000/framerate);
	
	document.addEventListener('keydown', function(event) {
		switch(event.keyCode) {
			case 37: kb_left = 1; break;
			case 38: kb_up = 1; break;
			case 39: kb_right = 1; break;
			case 40: kb_down = 1; break;
			case 65: kb_a = 1; break; //fov up
			case 90: kb_z = 1; break; //fov dwn
			case 81: auto_spin_mode = !auto_spin_mode; break; //key Q
		}
	});
	
	document.addEventListener('keyup', function(event) {
		switch(event.keyCode) {
			case 37: kb_left = 0; break;
			case 38: kb_up = 0; break;
			case 39: kb_right = 0; break;
			case 40: kb_down = 0; break;
			case 65: kb_a = 0; break;
			case 90: kb_z = 0; break;
		}
	});
}

function detect_collision(x, y) {
	var arr_x = Math.floor(x / cellw);
	var arr_y = Math.floor(y / cellw);
	
	if(arr_x <0 || arr_y <0) //out of bounds
		return 1;
	
	coll_cell_x = parseInt(arr_x);
	coll_cell_y = parseInt(arr_y);
	
	if(map[coll_cell_y][coll_cell_x] == "#")
		return 1; // hit
	else
		return 0;
}

function handle_kb() {
	if(kb_a)
		fov += rot_step;
	if(kb_z)
		fov -= rot_step;
	
	if(kb_left)
		pa -= rot_step;
	if(kb_right)
		pa += rot_step;
	
	if(kb_up) {
		var npx = px + mv_step * Math.cos(pa);
		var npy = py + mv_step * Math.sin(pa);
		
		if(!detect_collision(npx, npy)) {
			px = npx;
			py = npy;
		}
	}
	
	if(kb_down) {
		var npx = px - mv_step * Math.cos(pa);
		var npy = py - mv_step * Math.sin(pa);
		
		if(!detect_collision(npx, npy)) {
			px = npx;
			py = npy;
		}
	}
}

function draw_minimap () {
	var mm_x = c.width - mm_scale*10;
	var mm_y = c.height - mm_scale*10;
	
	for(var y=0; y<10; y++)
		for(var x=0; x<10; x++) {
			if(map[y][x] == "#")
				ctx.fillStyle = "#000000";
			else
				ctx.fillStyle = "#ffffff";
			
			ctx.fillRect(mm_x + x*mm_scale, mm_y + y*mm_scale, mm_scale, mm_scale);
		}
	
	var mm_px = mm_x + px / (10*cellw) * (10*mm_scale);
	var mm_py = mm_y + py / (10*cellw) * (10*mm_scale);
	
	//draw angle..
	var mm_pax = mm_scale * Math.cos(pa);
	var mm_pay = mm_scale * Math.sin(pa);
	
	ctx.strokeStyle="#0000ff";
	ctx.beginPath();
	ctx.moveTo(mm_px, mm_py);
	ctx.lineTo(mm_px + mm_pax, mm_py + mm_pay);
	ctx.stroke();
	
	//draw player..
	ctx.fillStyle = "#ff0000";		
	ctx.fillRect(mm_px - mm_scale/4, mm_py - mm_scale/4, mm_scale/2, mm_scale/2);
}

function calc_dist(cell_x, cell_y, ray_a) {
	var exact_dist=Number.MAX_SAFE_INTEGER, ndist = 0.0;
	var texture_x = 0;
	
	var k = Math.tan(ray_a);
	var b = py - k * px;
	
	/* a .
	   . b */
	var ptax = cell_x * cellw;
	var ptay = cell_y * cellw;
	var ptbx = (cell_x+1) * cellw;
	var ptby = (cell_y+1) * cellw;
	
	//visible ray in front of player: [px, py] => [px + vx*draw_dist, py + vy*draw_dist]
	var ux1 = px;
	var uy1 = py;
	var ux2 = px + Math.cos(ray_a)*draw_dist;
	var uy2 = py + Math.sin(ray_a)*draw_dist;
	var tmp;
	
	if(ux1>ux2) {tmp=ux1; ux1=ux2; ux2=tmp;}
	if(uy1>uy2) {tmp=uy1; uy1=uy2; uy2=tmp;}
	
	
	//bottom
	var fx2 = (ptby - b) / k;
	if(fx2>=ptax && fx2<=ptbx && fx2>=ux1 && fx2<=ux2 && ptby>=uy1 && ptby<=uy2) {
		ndist = Math.sqrt((px-fx2)*(px-fx2) + (py-ptby)*(py-ptby));
		if(ndist < exact_dist) {
			exact_dist = ndist;
			texture_x = fx2-ptax;
		}
	}
	
	//left
	var fy1 = k*ptax + b;
	if(fy1>=ptay && fy1<=ptby  && ptax>=ux1 && ptax<=ux2 && fy1>=uy1 && fy1<=uy2) {
		ndist = Math.sqrt((px-ptax)*(px-ptax) + (py-fy1)*(py-fy1));
		if(ndist<exact_dist) {
			exact_dist = ndist;
			texture_x = fy1-ptay;
		}
	}
	
	//top
	var fx1 = (ptay - b) / k;
	if(fx1>=ptax && fx1<=ptbx  && fx1>=ux1 && fx1<=ux2 && ptay>=uy1 && ptay<=uy2) {
		ndist = Math.sqrt((px-fx1)*(px-fx1) + (py-ptay)*(py-ptay));		
		if(ndist<exact_dist) {
			exact_dist = ndist;
			texture_x = fx1-ptax;
		}
	}
	
	//right
	var fy2 = k*ptbx + b;
	if(fy2>=ptay && fy2<=ptby  && ptbx>=ux1 && ptbx<=ux2 && fy2>=uy1 && fy2<=uy2) {
		ndist = Math.sqrt((px-ptbx)*(px-ptbx) + (py-fy2)*(py-fy2));
		if(ndist<exact_dist) {
			exact_dist = ndist;
			texture_x = fy2-ptay;
		}
	}
	
	return {texture_x: texture_x, dist: exact_dist};
}

//checker pattern shader
function shader(disp_x, texture_x, height) {
	//attenueate colors according to distance
	//max = #0000ff
	var col1 = parseInt(255 * height/c.height).toString(16);
	if(col1.length < 2) col1 = "0" + col1;
	var col_hi = "#0000" + col1;

	//max = #7d7dff (aka 125,125,255)
	var col2 = parseInt(125 * height/c.height).toString(16);
	if(col2.length < 2) col2 = "0" + col2;
	var col_lo = "#" + col2 + col2 + col1;
	
	//which col to start?
	var col_sel = 0;
	if(Math.floor(texture_x / ( cellw / shader_checkers)) % 2 == 0 ) col_sel = 1;

	//render
	for(var i=0; i<shader_checkers; i++) {
		var col = col_hi;
		if(col_sel) col = col_lo;

		//draw
		ctx.fillStyle=col;
		ctx.fillRect(disp_x, Math.floor((c.height - height) / 2 + i * height / shader_checkers), 1, Math.ceil(height / shader_checkers))

		//swap colors
		col_sel = !col_sel;
	}
}

function render_viewport(disp_x, disp_w, vpx, vpy) {
	for(var i = 0; i<c.width; i++) {
		var ray_a = (pa - fov / 2) + (i/c.width)*fov;
		
		var closest_collision = {texture_x: 0, dist: Number.MAX_SAFE_INTEGER};
				
		for(var y=0; y<10; y++)
			for(var x=0; x<10; x++)
				if(map[y][x] == "#") {
					var collision_info = calc_dist(x, y, ray_a);

					if(collision_info.dist < closest_collision.dist) {
						closest_collision.dist = collision_info.dist;
						closest_collision.texture_x = collision_info.texture_x;
					}
				}
		
		height = 2 * c.height / closest_collision.dist;
		
		if(height > c.height)
			height = c.height;
		
		shader(i, closest_collision.texture_x, height);
	}
	
	draw_minimap();
}

function update() {
	handle_kb();
	
	if(auto_spin_mode)
		pa += Math.PI / 90;
	
	ctx.fillStyle=bkg_grad;
	ctx.fillRect(0,0,c.width,c.height);
	
	render_viewport(0);
	//render_viewport(600);
}

</script> 

</head>

<body onload="init()" style="background-color:#000000;">
<canvas id="myCanvas" width="1200" height="600" >
Your browser does not support the HTML5 canvas tag.</canvas>
</body>
</html>

